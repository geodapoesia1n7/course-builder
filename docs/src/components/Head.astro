---
import { z } from 'astro/zod';
import config from 'virtual:starlight/user-config';

const HeadConfigSchema = () => z.array(
      z.object({
        /** Name of the HTML tag to add to `<head>`, e.g. `'meta'`, `'link'`, or `'script'`. */
        tag: z.enum(['title', 'base', 'link', 'style', 'meta', 'script', 'noscript', 'template']),
        /** Attributes to set on the tag, e.g. `{ rel: 'stylesheet', href: '/custom.css' }`. */
        attrs: z.record(z.union([z.string(), z.boolean(), z.undefined()])).default({}),
        /** Content to place inside the tag (optional). */
        content: z.string().default(''),
      })
    ).default([]);


type HeadUserConfig = z.input<ReturnType<typeof HeadConfigSchema>>;
type HeadConfig = z.output<ReturnType<typeof HeadConfigSchema>>;

function stripLeadingSlash(href: string) {
  if (href[0] === '/') href = href.slice(1);
  return href;
}

function stripTrailingSlash(href: string) {
  if (href[href.length - 1] === '/') href = href.slice(0, -1);
  return href;
}

function stripLeadingAndTrailingSlashes(href: string): string {
  href = stripLeadingSlash(href);
  href = stripTrailingSlash(href);
  return href;
}
const base = stripTrailingSlash(import.meta.env.BASE_URL);

function pathWithBase(path: string) {
  path = stripLeadingAndTrailingSlashes(path);
  return path ? base + '/' + path + '/' : base + '/';
}

function fileWithBase(path: string) {
  path = stripLeadingAndTrailingSlashes(path);
  return path ? base + '/' + path : base;
}

const HeadSchema = HeadConfigSchema();

function mergeHead(oldHead: HeadConfig, newHead: HeadConfig) {
  return [...oldHead.filter((tag) => !hasTag(newHead, tag)), ...newHead];
}

function sortHead(head: HeadConfig) {
  return head.sort((a, b) => {
    const aImportance = getImportance(a);
    const bImportance = getImportance(b);
    return aImportance > bImportance ? -1 : bImportance > aImportance ? 1 : 0;
  });
}

function getImportance(entry: HeadConfig[number]) {
  // 1. Important meta tags.
  if (
    entry.tag === 'meta' &&
    ('charset' in entry.attrs || 'http-equiv' in entry.attrs || entry.attrs.name === 'viewport')
  ) {
    return 100;
  }
  // 2. Page title
  if (entry.tag === 'title') return 90;
  // 3. Anything that isn’t an SEO meta tag.
  if (entry.tag !== 'meta') {
    // The default favicon should be below any extra icons that the user may have set
    // because if several icons are equally appropriate, the last one is used and we
    // want to use the SVG icon when supported.
    if (entry.tag === 'link' && 'rel' in entry.attrs && entry.attrs.rel === 'shortcut icon') {
      return 70;
    }
    return 80;
  }
  // 4. SEO meta tags.
  return 0;
}

function createHead(defaults: HeadUserConfig, ...heads: HeadConfig[]) {
  let head = HeadSchema.parse(defaults);
  for (const next of heads) {
  head = mergeHead(head, next);
  }
  return sortHead(head);
  }

function localizedUrl(url: URL, locale: string | undefined): URL {
  // Create a new URL object to void mutating the global.
  url = new URL(url)
  if (!config.locales) {
    // i18n is not configured on this site, no localization required.
    return url
  }
  if (locale === 'root') locale = ''
  /** Base URL with trailing `/` stripped. */
  const base = import.meta.env.BASE_URL.replace(/\/$/, '')
  const hasBase = url.pathname.startsWith(base)
  // Temporarily remove base to simplify
  if (hasBase) url.pathname = url.pathname.replace(base, '')
  const [_leadingSlash, baseSegment] = url.pathname.split('/')
  if (baseSegment && baseSegment in config.locales) {
    // We’re in a localized route, substitute the new locale (or strip for root lang).
    url.pathname = locale ? url.pathname.replace(baseSegment, locale) : url.pathname.replace('/' + baseSegment, '')
  } else if (locale) {
    // We’re in the root language. Inject the new locale if we have one.
    url.pathname = '/' + locale + url.pathname
  }
  // Restore base
  if (hasBase) url.pathname = base + url.pathname
  return url
}


const { entry, lang } = Astro.props;
const { data } = entry;

const canonical = Astro.site ? new URL(Astro.url.pathname, Astro.site) : undefined;
const description = data.description || config.description;

const ogImageUrl = `https://res.cloudinary.com/badass-courses/image/upload/w_1200,h_630,c_fill,f_auto/w_630,h_450,c_fit,co_rgb:FFFFFF,g_west,x_45,y_-40,l_text:arial_60_bold:${encodeURIComponent(data.title)}/course-builder-og-image-template_qfarun.png`

const headDefaults: z.input<ReturnType<typeof HeadConfigSchema>> = [
  { tag: 'meta', attrs: { charset: 'utf-8' } },
  {
    tag: 'meta',
    attrs: { name: 'viewport', content: 'width=device-width, initial-scale=1' },
  },
  { tag: 'title', content: `${data.title} ${config.titleDelimiter} ${config.title}` },
  { tag: 'link', attrs: { rel: 'canonical', href: canonical?.href } },
  { tag: 'meta', attrs: { name: 'generator', content: Astro.generator } },

  // Favicon
  {
    tag: 'link',
    attrs: {
      rel: 'shortcut icon',
      href: fileWithBase(config.favicon.href),
      type: config.favicon.type,
    },
  },
  // OpenGraph Tags
  { tag: 'meta', attrs: { property: 'og:title', content: data.title } },
  { tag: 'meta', attrs: { property: 'og:type', content: 'article' } },
  { tag: 'meta', attrs: { property: 'og:url', content: canonical?.href } },
  { tag: 'meta', attrs: { property: 'og:locale', content: lang } },
  { tag: 'meta', attrs: { property: 'og:description', content: description } },
  { tag: 'meta', attrs: { property: 'og:site_name', content: config.title } },
  { tag: 'meta', attrs: { property: 'og:image', content: data.ogImageUrl ? data.ogImageUrl : ogImageUrl } },
  // Twitter Tags
  {
    tag: 'meta',
    attrs: { name: 'twitter:card', content: 'summary_large_image' },
  },
  { tag: 'meta', attrs: { name: 'twitter:title', content: data.title } },
  { tag: 'meta', attrs: { name: 'twitter:description', content: description } },
  { tag: 'meta', attrs: { name: 'twitter:image', content: data.ogImageUrl ? data.ogImageUrl : ogImageUrl } },
];

if (description)
  headDefaults.push({
    tag: 'meta',
    attrs: { name: 'description', content: description },
  });

// Link to language alternates.
if (canonical && config.isMultilingual) {
  for (const locale in config.locales) {
    const localeOpts = config.locales[locale];
    if (!localeOpts) continue;
    headDefaults.push({
      tag: 'link',
      attrs: {
        rel: 'alternate',
        hreflang: localeOpts.lang,
        href: localizedUrl(canonical, locale).href,
      },
    });
  }
}

function hasOneOf(head: HeadConfig, entry: HeadConfig[number], keys: string[]): boolean {
  const attr = getAttr(keys, entry);
  if (!attr) return false;
  const [key, val] = attr;
  return head.some(({ tag, attrs }) => tag === entry.tag && attrs[key] === val);
}

function getAttr(
  keys: string[],
  entry: HeadConfig[number]
): [key: string, value: string | boolean] | undefined {
  let attr: [string, string | boolean] | undefined;
  for (const key of keys) {
    const val = entry.attrs[key];
    if (val) {
      attr = [key, val];
      break;
    }
  }
  return attr;
}

function hasTag(head: HeadConfig, entry: HeadConfig[number]): boolean {
  switch (entry.tag) {
    case 'title':
      return head.some(({ tag }) => tag === 'title');
    case 'meta':
      return hasOneOf(head, entry, ['name', 'property', 'http-equiv']);
    default:
      return false;
  }
}

// Link to sitemap, but only when `site` is set.
if (Astro.site) {
  headDefaults.push({
    tag: 'link',
    attrs: {
      rel: 'sitemap',
      href: fileWithBase('/sitemap-index.xml'),
    },
  });
}

// Link to Twitter account if set in Starlight config.
if (config.social?.twitter) {
  headDefaults.push({
    tag: 'meta',
    attrs: {
      name: 'twitter:site',
      content: new URL(config.social.twitter.url).pathname,
    },
  });
}

const head = createHead(headDefaults, config.head, data.head);
---

{head.map(({ tag: Tag, attrs, content }) => <Tag {...attrs} set:html={content} />)}